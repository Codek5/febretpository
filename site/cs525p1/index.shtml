<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta name="GENERATOR" content="PPWIZARD version 08.298 on UNKNOWN, FREE tool for Windows, OS/2, DOS and UNIX by Dennis Bareis (http://dennisbareis.com/ppwizard.htm)">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>febretPository</title>
<link rel="icon" type="image/png" href="../icon.png">
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../default.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- BEGIN Header -->
<div id="header">
<h1>febretPository<h1>
<!-- <h2>Successfully Climbing the Ballmer Peak Since 2006</h2> -->
</div>
<!-- END Header -->
<!-- BEGIN Menu -->
<div id="menu">
<ul>
<li><a href="../main/index.shtml">Home</a></li>
<li><a href="http://febretpository.blogspot.com/">Blog</a></li>
<li><a href="../main/bio.shtml">About Me</a></li>
<li><a href="../main/pastProjects.shtml">Past Projects</a></li>
<li><a href="../publications/publications.shtml">Publications</a></li>
<li><a href="http://www.evl.uic.edu/core.php?mod=4&type=5&indi=316">EVL</a></li>
</ul>
</div>
<!-- END Menu -->
<div id="content">
<div class="addthis_toolbox addthis_default_style">
<a href="http://www.addthis.com/bookmark.php?v=250&amp;username=xa-4bc5321941e02079" class="addthis_button_compact"><img src="../images/fbico.png" style="float: left; border: none; padding: 0; "/>Share this Page</a>
</div><br/>
<script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#username=xa-4bc5321941e02079"></script>
<!-- AddThis Button END -->
<div class="section">
<h2>CS525 Project 1 - Kodachrome</h2>
<p>
The objective for this project was to process a stream of images captured from the webcam, and apply a set of vertex, fragment and geometry shaders to
achieve different visual effects. The shaders had to be written using the OpenGL Shading Language (GLSL). My application made use of the OpenCV library
for the webcam capture part. OpenCV has also been used to integrate face recognition support into one of the shaders.
</p>
</div>
<div class="section">
<h2>How To Use The Application</h2>
<p>
The application presenta a total of 12 shader programs, organized into 3 pages of 4 programs each. Most of the shaders expose a configurable
parameter that can be modified using the keyboard as the following section explains.
</p>
<p>
Here is a quick reference of the keys used by the application:
<ul>
<li><b>[1] [2] [3]</b> - select the currently displayed program page</li>
<li><b>[i] [o] [k] [l]</b> - Maximize one of the four views of the current page</li>
<li><b>[j]</b> - Go back to the 4-view page mode</li>
<li><b>[q] [z] [a]</b> - Increase, decrease and reset to default the configurable parameter for the <b>Top Left View</b></li>
<li><b>[w] [x] [s]</b> - Increase, decrease and reset to default the configurable parameter for the <b>Top Right View</b></li>
<li><b>[e] [c] [d]</b> - Increase, decrease and reset to default the configurable parameter for the <b>Bottom Left View</b></li>
<li><b>[r] [v] [f]</b> - Increase, decrease and reset to default the configurable parameter for the <b>Bottom Right View</b></li>
<li><b>[n]</b> - Capture the current webcam image as background. Used in some of the views.</li>
<li><b>[m]</b> - Toggle face detection. Used in the funny mirror view.</li>
<li><b>[b]</b> - Enable / Disable the live webcam stream.</li>
</ul>
</p>
</p>
</div>
<div class="section">
<h2>Shaders</h2>
<div><img style="float:left" src="./s1.png" width="300"/>
<h3>Saturation</h3>
<p><b>Main techniques:</b> fragment shader saturation adjustment (saturation.frag)</p>
<p>
This shader simply displays the current webcam feed, allowing the user to control the saturation level of
the image. The fragment shader computes a black - and white value for each fragment, and mixes that value
with the original color for each color channel, depending on an external, user customizable parameter.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s2.png" width="300"/>
<h3>Posterize</h3>
<p><b>Main techniques:</b> fragment shader color quantization (posterize1.frag)</p>
<p>
The fragment shader used in this view limits the number of color shades for each color channel
depending on the external shader parameter. The quantization is done by multiplying, rounding and then
dividing each fragment color by the user parameter:
</p>
<code>color.r = round(color.r * param) / param;</code>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s3.png" width="300"/>
<h3>Color Threshold</h3>
<p><b>Main techniques:</b> fragment shader single channel threshold (colorThreshold.frag)</p>
<p>
This view uses a fragment shader that computes the difference between one of the fragment colors (red in this case) and
the average of the other two channels. If the difference is bigger than a user specified threshold, the fragment passes through
the shader as it is. Otherwise, it is rendered black and white.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s4.png" width="300"/>
<h3>Hologram</h3>
<p><b>Main techniques:</b> background subtraction, scanline simulation (hologram.frag)</p>
<p>
This view simulates a 'hologram' effect by subtracting the current webcam feed from a fixed background
(press <b>[n]</b> to capture a background image from the webcam). The subtraction result is colored using a bluish
palette and modulated by a low and high frequency sine function, to simulate scanlines and flicker.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s5.png" width="300"/>
<h3>Emboss</h3>
<p><b>Main techniques:</b> Embossing (emboss.frag)</p>
<p>
This view simply applies an emboss convolution filter to a black and white version of the camera image. Image embossing is
explained in more detail <a href="http://en.wikipedia.org/wiki/Image_embossing">Here.</a>
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s6.png" width="300"/>
<h3>Funny Mirror</h3>
<p><b>Main techniques:</b> Polar coordinate distortion, face detection (funmirror.frag)</p>
<p>
This view uses a fragment shader that smulates a funny mirror effect by distorting the image texture
coordinates after converting them into <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar form.</a>
A brief explanation of some of the effects implemented by this shader can be found <a href="http://dem.ocracy.org/libero/photobooth/">here.</a>
When face detection is turned on, the shader gets the face rectangle identified by OpenCV as a <code>uniform vec4</code>.
The shader then re-centers the effect using some simple math on te texture coordinate conversion.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s7.png" width="300"/>
<h3>Live Environment Mapping</h3>
<p><b>Main techniques:</b> Vertex-based spherical environment mapping (envMap.vert, EnvMap.frag)</p>
<p>
This view implements a basic environment mapping shader, using the webcam feed as a sphere map. Since the
webcam image does not map very well on a sphere, a simple technique has been used to avoid mapping artifacts at the texture boundaries.
When the reflection vector gets close to the boundaries, the texture result is increasily mixed with a constant color.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s8.png" width="300"/>
<p><b>Main techniques:</b> Image difference, Gaussian blur, accumulation texture (smoke2.frag)</p>
<h3>Motion Accumulator</h3>
<p>
The fragment shader used in this view makes use of three separate inputs to generate its result: the current webcam frame,
the previous frame and <b>The previous rendering result by the shader itself.</b> The shader computes the black and white
difference between the current and previous frame, adds is to the previous rendering result and finally blurs it. After being written
to the frame buffer, the output is copied to a texture so it can be passed back to this shader during the next rendering.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s9.png" width="300"/>
<h3>Bump Mapped Coin</h3>
<p><b>Main techniques:</b> Environment-mapped bump mapping (envMap.vert coin.frag)</p>
<p>
This view uses the embossed image generated for one of the previous views to build a bump map and apply it to the surface of a short
cylinder in order to make it look like a coin. For each fragment of the emboss image we compute the x and y gradients and normalize their
cross product to get the surface normal at that point. The normal is the used to compute a reflection vector to lookup into a sperical environment
map, generated again from the webcam feed (as it was for the Live Environment Mapping view).
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s10.png" width="300"/>
<h3>Comic book</h3>
<p><b>Main techniques:</b> Fixed palette posterize, embossing (envMap.vert coin.frag)</p>
<p>
This view implements a fixed-palette posterization technique: Instead of simply quantizing the color channels,
we decide <b>a priori</b> which colors we want to use (in this case light shades of blue, red and white). For
each fragment we then compute the distance to each one of the colors, and we choose the one closest to the original.
The 'comic book' effect is enhanced by adding contours to the result using an embossing filter.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s12.png" width="300"/>
<h3>Ghost</h3>
<p><b>Main techniques:</b> Texture deformation (ghost.frag)</p>
<p>
This fragment shader uses the output of the <b>Motion Accumulator</b> view to deform a fixed image
(i.e. a background image captured from the webcam using <b>[n]</b>). The motion accumulator output
itself is slightly blended with the result inside the fragment shader to give a subtle, ghosthy
presence effect on the image.
</p>
</div>
<br style="clear: left" />
<div><img style="float:left" src="./s11.png" width="300"/>
<h3>Geometry Shader Tessellation</h3>
<p><b>Main techniques:</b> Polygon tessellation, environment mapping, vertex shader displacement mapping (heightmap.vert envMap.frag)</p>
<p>
This view uses a geometry shader to tessellate a quad in order to form a grid with any desired level of detail. The grid vertices are fed
to a vertex shader that used the <b>Motion Accumulator</b> result as a lookup texture to modify the vertex y coordinate. Its worth noting how the
vertex normals are not valid anymore at this point so we need to recompute them inside the shader through the same technique used for the <b>Bump Mapped Coin</b>.
The resulting deformed surface is then shaded using an environment mapping fragment shader.
</p>
</div>
</div>
<div class="section">
<h2>Downloads</h2>
<h3 align="center"><a href="../downloads/index.shtml#cs525">>>> DOWNLOAD SOURCE AND WIN32 BINARIES <<<</a></h3>
</div>
<div style="clear: both;">&nbsp;</div>
</div>
<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=3151844;
var sc_invisible=0;
var sc_partition=33;
var sc_security="622697c6";
</script>
<script type="text/javascript" src="http://www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a class="statcounter" href="http://www.statcounter.com/"><img class="statcounter" src="http://c34.statcounter.com/3151844/0/622697c6/0/" alt="web metrics" /></a></div></noscript>
<!-- End of StatCounter Code --><br><a href="http://my.statcounter.com/project/standard/stats.php?project_id=3151844&amp;guest=1">myMigthyStats</a>
</body>
</html>
